#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
#ifndef KOCHAVACONSENT_SWIFT_H
#define KOCHAVACONSENT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="KochavaConsent",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


SWIFT_CLASS("_TtC14KochavaConsent7KVACCPA")
@interface KVACCPA : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@protocol KVAConsentAuditEntryAdder;

SWIFT_PROTOCOL("_TtP14KochavaConsent33KVAConsentAuditEntryAdderProvider_")
@protocol KVAConsentAuditEntryAdderProvider
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
@end

@class KVAConsentAuditEntry;

SWIFT_PROTOCOL("_TtP14KochavaConsent25KVAConsentAuditEntryAdder_")
@protocol KVAConsentAuditEntryAdder
/// Adds an audit entry.
- (void)addEntry:(KVAConsentAuditEntry * _Nonnull)entry;
@end

@class NSString;

/// A controller for working with consent audit entries.
SWIFT_CLASS_NAMED("KVAConsentAudit")
@interface KVAConsentAudit : NSObject <KVAConsentAuditEntryAdder, KVAConsentAuditEntryAdderProvider>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)addEntry:(KVAConsentAuditEntry * _Nonnull)entry;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
@end


/// An audit entry.
SWIFT_CLASS_NAMED("KVAConsentAuditEntry")
@interface KVAConsentAuditEntry : NSObject
/// A method which adds an audit entry.
/// \param textString A string of text.
///
+ (void)addWithTextString:(NSString * _Nonnull)textString;
/// A method which adds an audit entry.
/// \param textString A string of text.
///
/// \param adder An instance which conforms to protocol KVAConsentAuditEntryAdderProvider.
///
+ (void)addWithTextString:(NSString * _Nonnull)textString adder:(id <KVAConsentAuditEntryAdderProvider> _Nullable)adder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class KVAUSPrivacy;

SWIFT_PROTOCOL_NAMED("KVAUSPrivacyProvider")
@protocol KVAUSPrivacyProvider
/// An instance of class KVAUSPrivacy.
@property (nonatomic, readonly, strong) KVAUSPrivacy * _Nonnull usPrivacy;
@end

@class KVAConsentConfiguration;

SWIFT_PROTOCOL_NAMED("KVAConsentConfigurationMutableProvider")
@protocol KVAConsentConfigurationMutableProvider
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration_mutable;
@end

@class KVAContext;
@class KVAConsentConfig;
@class KVAConsentGeneral;
@class KVANetworking;

/// The class KVAConsentClient provides an interface between a host application and Kochava’s Consent servers.
SWIFT_CLASS_NAMED("KVAConsentClient")
@interface KVAConsentClient : NSObject <KVAConsentAuditEntryAdderProvider, KVAConsentConfigurationMutableProvider, KVAUSPrivacyProvider>
/// A shared instance, for convenience.
/// This is the preferred way of using an consentClient instance.  To complete the integration you must call func <code>registerIdentity(withNameString:valueString:)</code> followed by func <code>start()</code>.  You may alternatively use a constructor to create your own consentClient.  The shared instance simplifies your implementation as you do not need to store an consentClient instance somewhere in a public location in your own code.
/// By default this instance will use the default storage location equivalent to calling <code>init(storageIdString:)</code> with storageIdString nil.  If you wish to specify an alternative storage location, see var <code>sharedStorageIdString</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAConsentClient * _Nonnull shared;)
+ (KVAConsentClient * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// A shared instance, for convenience— optional.
/// See var <code>shared</code>.  This variable will be nil prior to the shared instance being defaulted.  This may be used to optionally invalidate any existing shared instance without causing it to first be defaulted in the process.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAConsentClient * _Nullable shared_optional;)
+ (KVAConsentClient * _Nullable)shared_optional SWIFT_WARN_UNUSED_RESULT;
/// The shared instance, an ambiguated form of the var <code>shared</code> which conforms to protocol KVASharedPropertyProvider.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) id _Nonnull sharedInstance;)
+ (id _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// Create a consent client.
/// You rarely create instances of class KVAConsentClient.  Instead, you start the provided shared instance using one of the start instance methods.  See static var <code>shared</code>.
/// <h2>Example</h2>
/// \code
/// class MyClass
/// {
///     let consentClient = KVAConsentClient()
/// }
///
/// \endcode
- (nonnull instancetype)init;
/// Create a consentClient.
/// You rarely create instances of class KVAConsentClient.  Instead, you start the provided shared instance using one of the start instance methods.  See static var <code>shared</code>.
/// <h2>Example</h2>
/// \code
/// class MyClass
/// {
///     let consentClient = KVAConsentClient(storageIdString: "alternate")
/// }
///
/// \endcode\param storageIdString An optional storage identifier.  The storage identifier should be left unset (nil) unless you have a reason to not use the default storage space.  See default constructor KVAConsentClient().
///
- (nonnull instancetype)initWithStorageIdString:(NSString * _Nullable)storageIdString OBJC_DESIGNATED_INITIALIZER;
/// Configure the instance with an object.
/// This is the same method which is used to configure the instance when the <code>config</code> response is returned from Kochava’s servers.  It can also be called from the host to change the defaults of various parameters (or else override them).  The structure of the object you provide has the same capability as that which the server may return.  Additionally you can wrap the parameters you provide in special objects with special keys <code>$default$</code>, <code>$default.append$</code>, <code>$override$</code>, or <code>$override.append$</code>, to indicate how these options are treated relative to the server’s options.
/// | Special Key | Treatment  |
/// — | —
/// $default$ |  Elements within this object will serve as a default for any options of the same name when not specified by the server.  The use of this option will replace any previous use of <code>$default$</code> or <code>$default.append$</code>.
/// $default.append$ |  Elements within this object will append to any previously established <code>$default$</code>.  You may use this without using <code>$default$</code> first, allowing you to specify multiple defaults over the course of multiple configuration calls.  The use of this option is generally considered preferred relative to the others.  That is because as a default it still allows for the server to specify overrides, and as an append it will respect any other previous configuration calls which you may have made at other times and places.
/// $override$ |  Elements within this object will override any options of the same name specified by the server.  Use this option when you do not want to allow the server to specify overrides.  The use of this option will replace any previous use of <code>$override$</code> or <code>$override.append$</code>.
/// $override.append$ |  Elements within this object will append to any previously established <code>$override$</code>.  You may use this without using <code>$override$</code> first, allowing you to specify multiple overrides over the course of multiple configuration calls.  The use of this option is generally preferred to <code>$override$</code>.  That is because as an append it will respect any other previous configuration calls which you may have made at other times and places.
/// The following example will deny the collection of two datapoints, the idfa and idfv.  Ordinarily the best way to do this is through the Kochava dashboard, where these can be controlled within multiple version(s) of an app already in production.  However, if at build time you wanted to explicitly override server-side control, such that these two items effectively always appear in the deny datapoints list, the following code would do so:
/// <h2>Example</h2>
/// \code
/// // consentClientConfigureObject
/// let consentClientConfigureObject =
/// [
///     "$override.append$":
///     [
///         "privacy":
///         [
///             "deny_datapoints":
///             [
///                 "idfa",
///                 "idfv"
///             ]
///         ]
///     ]
/// ]
///
/// // KVAConsentClient
/// KVAConsentClient.shared.configure(with: consentClientConfigureObject, context: .host)
/// KVAConsentClient.shared.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
/// KVAConsentClient.shared.start()
///
/// \endcode\param object An object from which to configure the instance.  This is most commonly a JSON object.
///
/// \param context The context from which the object was provided.  In rare cases this may have some bearing on the proper interpretation of what was provided.
///
- (void)configureWith:(id _Nullable)object context:(KVAContext * _Nullable)context;
/// Configure the instance with an object.
/// This function is equivalent to func configure(with:context) however this does not first dispatch to the globalSerial queue.  It is the protocol conformance of KVAConfigureWithProtocol.  You should not use this function directly unless you have a specific need to not perform the preferred dispatch.
- (void)kva_configureWith:(id _Nullable)object context:(KVAContext * _Nullable)context;
/// Register an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
///
/// \endcode
- (void)registerIdentityWithNameString:(NSString * _Nonnull)nameString valueString:(NSString * _Nonnull)valueString;
/// Unregister an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.unregisterIdentity(withNameString: "_SOME_NAME_")
///
/// \endcode
- (void)unregisterIdentityWithNameString:(NSString * _Nonnull)nameString;
/// Start the consent client instance.
/// An identity must be registered prior to making this call.  To do this, instead see func <code>registerIdentity(withNameString:valueString:)</code>.  This method is called by those two methods, and provides public conformance to protocol KVAStartable.  This method can be used to start an instance of a consent client which was created from decoded JSON.
- (void)start;
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Invalidate the instance.
/// When using this method with the shared instance, you are guaranteed to be re-defaulted a new instance the next time it is referenced, and you may immediately move forward to re-configure and start it.
- (void)invalidate;
/// Invalidate the instance.
/// See func <code>invalidate()</code>
- (void)invalidateWithAsyncBool:(BOOL)asyncBool printLogMessageBool:(BOOL)printLogMessageBool;
/// A feature which is responsible for adding audit entries.
@property (nonatomic, readonly, strong) KVAConsentAudit * _Nonnull audit;
/// A feature which is responsible for controlling and updating the configuration of the consent client instance.
@property (nonatomic, readonly, strong) KVAConsentConfig * _Nonnull config;
/// A feature which is a public configuration for consent.
/// This form of the configuration is a copy.  You should retain and instance within the scope where you are working with it so that the configuration will be consistent and not mutate within that scope.
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration;
/// A feature which is a public configuration for consent— mutable.
/// This form of the configuration can mutate.  The form that the host can access will be a copy so that it does not mutate within their scope (unless they reference the instance multiple times).
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration_mutable;
/// A feature which encapsulates all of the general aspects of a consent client not belonging to any other encapsulated features.
@property (nonatomic, readonly, strong) KVAConsentGeneral * _Nonnull general;
/// A feature which provides networking support.
/// The networking instance manages the exchange of data between the client and various server(s), along with the associated tasks, network transactions, adapters, and instructions.  See class KVANetworking in module KochavaCore.
@property (nonatomic, readonly, strong) KVANetworking * _Nonnull networking;
/// A feature which is responsible for working with US Privacy (IAB).
@property (nonatomic, readonly, strong) KVAUSPrivacy * _Nonnull usPrivacy;
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
/// A string used as a  storage identifier for the shared instance.
/// This is used to further qualify where in persistent storage the information for this instance is stored.  This property should not be used except in very specific circumstances.  Please contact your client success representative if you are interested in using this.  You would set this value to a short unique string consisting of regular alphanumeric characters.
/// Following deployment with a given storage identifer this should never be changed except to represent an entirely new integration.
/// If used, it is imperative that this value be consistently set prior to accessing the shared instance for the first time.  You must make accommodations to set this as early as possible, where it would be prior to any access to var <code>shared</code> throughout all of your code.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable sharedStorageIdString;)
+ (NSString * _Nullable)sharedStorageIdString SWIFT_WARN_UNUSED_RESULT;
+ (void)setSharedStorageIdString:(NSString * _Nullable)sharedStorageIdString;
/// A closure which is called when there is an update to the configuration.
/// This can be used to prompt the user for consent and to enable and/or disable functionality.
@property (nonatomic, copy) void (^ _Nullable didReceiveConfigurationBlock)(KVAConsentConfiguration * _Nonnull);
/// A boolean indicating whether or not the instance has been started.
@property (nonatomic, readonly) BOOL startedBool;
@end


/// A feature which is responsible for controlling and updating the configuration of the consent instance.
/// This feature interfaces with Kochava’s servers to provide a server-based configuration.
SWIFT_CLASS_NAMED("KVAConsentConfig")
@interface KVAConsentConfig : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("KVAConsentConfiguration")
@interface KVAConsentConfiguration : NSObject <NSCopying>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Returns a boolean indicating if a mode is currently present.
- (BOOL)modePresentWithNameString:(NSString * _Nonnull)nameString SWIFT_WARN_UNUSED_RESULT;
/// A dictionary containing arbitrary configuration values meant for the host app’s consumption.
@property (nonatomic, readonly, copy) NSDictionary * _Nonnull hostDictionary;
/// Array of strings indicating the current applicable consent modes.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull modeStringArray;
/// A boolean indicating whether or not at least one configuration has completed and the configuration object is ready for use.
/// This might be checked instead of waiting for the optional closure to be called.
@property (nonatomic, readonly) BOOL readyBool;
@end



/// A feature which is responsible for the collection of datapoints.
/// <h1>Thread Safety</h1>
/// The underlying APIs being used to collect datapoints fall under various classifications of thread safety.  If an API is not thread safe then it must be collected on the main thread, otherwise it may be collected on the caller’s thread.  Anything which must be collected on the main thread must be viewed as asynchronous, along with those APIs which are themselves inherently asynchronous;  however, all other APIs may be viewed as synchronous.  In every case these thread safety classifications apply to the internal implementation stategies of the associated adapters, but the adapters themselves exist in part to create wrappers which have their own API(s) which are themselves uniform and universally thread safe.
/// Apple’s documentation on thread safety can be found here:
/// https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html
/// <h2>Internal Implementation Strategy Classifications</h2>
/// | Class | Safe | Notes |
/// — | — | —
/// Bundle | Yes | Apple’s documentation classifies Bundle under “Thread-Safe Classes and Functions”.
/// Locale | Yes* | Locale thread safety is undocumented by Apple at the time of this writing, but their broader documentation on thread safety says, “Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads.”  Because none of the properties which are being accessed are taken to be mutable, generally speaking, what we are doing is taken to be thread safe.
/// ProcessInfo | Yes | ProcessInfo is said to be thread-safe as of macOS 10.7 and later.
/// UIDevice | Yes* | UIDevice thread safety is undocumented by Apple at the time of this writing, but their broader documentation on thread safety says, “Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads.”  Because none of the properties which are being accessed are taken to be mutable, generally speaking, what we are doing may be thread safe.  However, Apple’s docs also say, “For the most part, UIKit classes should be used only from an application’s main thread. This is particularly true for classes derived from UIResponder or that involve manipulating your application’s user interface in any way.”  UIDevice is part of UIKit, however it is not derived from UIResponder (but rather NSObject).  This method is taken to not be involved in manipulating the application’s user interface.   https://developer.apple.com/documentation/uikit
/// Special | Varies | This classification is used for special cases.  There should be additional documentation in reference(s) which talk about the case.
/// <em>Yes*</em> - Items with this designation are taken to be safe.  They lack some level of documentation and/or clarity where thread safety is concerned, but often generally have a track record of being safe.
SWIFT_CLASS_NAMED("KVAConsentDatapoints")
@interface KVAConsentDatapoints : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A feature which encapsulates all of the general aspects of a consent not belonging to any other encapsulated features.
SWIFT_CLASS_NAMED("KVAConsentGeneral")
@interface KVAConsentGeneral : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Register an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.general.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
///
/// \endcode
- (void)registerIdentityWithNameString:(NSString * _Nonnull)nameString valueString:(NSString * _Nonnull)valueString;
/// Unregister an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.general.unregisterIdentity(withNameString: "_SOME_NAME_")
///
/// \endcode
- (void)unregisterIdentityWithNameString:(NSString * _Nonnull)nameString;
@end


/// A feature which is responsible for consent-specific logging activities.
/// You can set the KVALog.shared.level to control what level of log messages are printed, as well as configure various other options through module KochavaCore class KVALog.
SWIFT_CLASS_NAMED("KVAConsentLogging")
@interface KVAConsentLogging : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class KVAProduct;

/// A class which defines the consent product.
/// A product in this context generally refers to the result of a build.
/// note:
/// This is currently overridden to be a subclass of NSObject rather than KVAProduct so that it can be represented in Objective-C.  If you use KVAProduct it will still build, but the automatic module registration will fail to locate the class.  You can see early evidence of the problem if you also make the shared property be of the class type, where the compiler will say that it cannot use @objc because it cannot be expressed in Objective-C.  This is apparently a problem that Swift has providing Objective-C compatibility to Swift classes which subclass other Swift classes across modules.  For example, KVACoreProduct does not have this problem, presumably because it’s in the same module as KVAProduct.  In order to convert this class to subclass KVAProduct, or to subsequently allow shared to be of the class’ type, a means of registering/loading the class as a Swift-only class would be required.  More importantly, however, we’d need to give up public Objective-C support.  Since that doesn’t seem possible, the only alternative would be that Apple fixes this issue and provides the necessary support, assuming that’s possible.
SWIFT_CLASS_NAMED("KVAConsentProduct")
@interface KVAConsentProduct : NSObject
/// The singleton shared instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAProduct * _Nonnull shared;)
+ (KVAProduct * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Defines the parameters for the tracker product.
SWIFT_CLASS("_TtC14KochavaConsent23KVAConsentProductParams")
@interface KVAConsentProductParams : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A feature which provides for the internal observation of sessions.
SWIFT_CLASS_NAMED("KVAConsentSessions")
@interface KVAConsentSessions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class KVAUSPrivacyStringValue;

SWIFT_CLASS_NAMED("KVAUSPrivacy")
@interface KVAUSPrivacy : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if the publisher intends for this transaction to be covered under the IAB Limited Service Provider Agreement (LSPA).
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull coveredByLSPA;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if explicit notice has been given.
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull explicitNoticeGiven;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if the user has opted out of the sale of their data.
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull userOptedOutOfSale;
/// The IAB US Privacy string.
@property (nonatomic, copy) NSString * _Nullable string;
@end



/// An object which represents the value within the US Privacy String.
SWIFT_CLASS_NAMED("KVAUSPrivacyStringValue")
@interface KVAUSPrivacyStringValue : NSObject
/// An enumerated shared instance of KVAUSPrivacyStringValue for Yes.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull yes;)
+ (KVAUSPrivacyStringValue * _Nonnull)yes SWIFT_WARN_UNUSED_RESULT;
/// An enumerated shared instance of KVAUSPrivacyStringValue for No.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull no;)
+ (KVAUSPrivacyStringValue * _Nonnull)no SWIFT_WARN_UNUSED_RESULT;
/// An enumerated shared instance of KVAUSPrivacyStringValue for Not Applicable.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull notApplicable;)
+ (KVAUSPrivacyStringValue * _Nonnull)notApplicable SWIFT_WARN_UNUSED_RESULT;
/// The name of the value.
@property (nonatomic, readonly, copy) NSString * _Nonnull nameString;
/// The raw string value as found in the IAB US Privacy String at a given position.
@property (nonatomic, readonly, copy) NSString * _Nonnull rawString;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
#ifndef KOCHAVACONSENT_SWIFT_H
#define KOCHAVACONSENT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="KochavaConsent",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


SWIFT_CLASS("_TtC14KochavaConsent7KVACCPA")
@interface KVACCPA : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@protocol KVAConsentAuditEntryAdder;

SWIFT_PROTOCOL("_TtP14KochavaConsent33KVAConsentAuditEntryAdderProvider_")
@protocol KVAConsentAuditEntryAdderProvider
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
@end

@class KVAConsentAuditEntry;

SWIFT_PROTOCOL("_TtP14KochavaConsent25KVAConsentAuditEntryAdder_")
@protocol KVAConsentAuditEntryAdder
/// Adds an audit entry.
- (void)addEntry:(KVAConsentAuditEntry * _Nonnull)entry;
@end

@class NSString;

/// A controller for working with consent audit entries.
SWIFT_CLASS_NAMED("KVAConsentAudit")
@interface KVAConsentAudit : NSObject <KVAConsentAuditEntryAdder, KVAConsentAuditEntryAdderProvider>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)addEntry:(KVAConsentAuditEntry * _Nonnull)entry;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
@end


/// An audit entry.
SWIFT_CLASS_NAMED("KVAConsentAuditEntry")
@interface KVAConsentAuditEntry : NSObject
/// A method which adds an audit entry.
/// \param textString A string of text.
///
+ (void)addWithTextString:(NSString * _Nonnull)textString;
/// A method which adds an audit entry.
/// \param textString A string of text.
///
/// \param adder An instance which conforms to protocol KVAConsentAuditEntryAdderProvider.
///
+ (void)addWithTextString:(NSString * _Nonnull)textString adder:(id <KVAConsentAuditEntryAdderProvider> _Nullable)adder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class KVAUSPrivacy;

SWIFT_PROTOCOL_NAMED("KVAUSPrivacyProvider")
@protocol KVAUSPrivacyProvider
/// An instance of class KVAUSPrivacy.
@property (nonatomic, readonly, strong) KVAUSPrivacy * _Nonnull usPrivacy;
@end

@class KVAConsentConfiguration;

SWIFT_PROTOCOL_NAMED("KVAConsentConfigurationMutableProvider")
@protocol KVAConsentConfigurationMutableProvider
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration_mutable;
@end

@class KVAContext;
@class KVAConsentConfig;
@class KVAConsentGeneral;
@class KVANetworking;

/// The class KVAConsentClient provides an interface between a host application and Kochava’s Consent servers.
SWIFT_CLASS_NAMED("KVAConsentClient")
@interface KVAConsentClient : NSObject <KVAConsentAuditEntryAdderProvider, KVAConsentConfigurationMutableProvider, KVAUSPrivacyProvider>
/// A shared instance, for convenience.
/// This is the preferred way of using an consentClient instance.  To complete the integration you must call func <code>registerIdentity(withNameString:valueString:)</code> followed by func <code>start()</code>.  You may alternatively use a constructor to create your own consentClient.  The shared instance simplifies your implementation as you do not need to store an consentClient instance somewhere in a public location in your own code.
/// By default this instance will use the default storage location equivalent to calling <code>init(storageIdString:)</code> with storageIdString nil.  If you wish to specify an alternative storage location, see var <code>sharedStorageIdString</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAConsentClient * _Nonnull shared;)
+ (KVAConsentClient * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// A shared instance, for convenience— optional.
/// See var <code>shared</code>.  This variable will be nil prior to the shared instance being defaulted.  This may be used to optionally invalidate any existing shared instance without causing it to first be defaulted in the process.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAConsentClient * _Nullable shared_optional;)
+ (KVAConsentClient * _Nullable)shared_optional SWIFT_WARN_UNUSED_RESULT;
/// The shared instance, an ambiguated form of the var <code>shared</code> which conforms to protocol KVASharedPropertyProvider.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) id _Nonnull sharedInstance;)
+ (id _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// Create a consent client.
/// You rarely create instances of class KVAConsentClient.  Instead, you start the provided shared instance using one of the start instance methods.  See static var <code>shared</code>.
/// <h2>Example</h2>
/// \code
/// class MyClass
/// {
///     let consentClient = KVAConsentClient()
/// }
///
/// \endcode
- (nonnull instancetype)init;
/// Create a consentClient.
/// You rarely create instances of class KVAConsentClient.  Instead, you start the provided shared instance using one of the start instance methods.  See static var <code>shared</code>.
/// <h2>Example</h2>
/// \code
/// class MyClass
/// {
///     let consentClient = KVAConsentClient(storageIdString: "alternate")
/// }
///
/// \endcode\param storageIdString An optional storage identifier.  The storage identifier should be left unset (nil) unless you have a reason to not use the default storage space.  See default constructor KVAConsentClient().
///
- (nonnull instancetype)initWithStorageIdString:(NSString * _Nullable)storageIdString OBJC_DESIGNATED_INITIALIZER;
/// Configure the instance with an object.
/// This is the same method which is used to configure the instance when the <code>config</code> response is returned from Kochava’s servers.  It can also be called from the host to change the defaults of various parameters (or else override them).  The structure of the object you provide has the same capability as that which the server may return.  Additionally you can wrap the parameters you provide in special objects with special keys <code>$default$</code>, <code>$default.append$</code>, <code>$override$</code>, or <code>$override.append$</code>, to indicate how these options are treated relative to the server’s options.
/// | Special Key | Treatment  |
/// — | —
/// $default$ |  Elements within this object will serve as a default for any options of the same name when not specified by the server.  The use of this option will replace any previous use of <code>$default$</code> or <code>$default.append$</code>.
/// $default.append$ |  Elements within this object will append to any previously established <code>$default$</code>.  You may use this without using <code>$default$</code> first, allowing you to specify multiple defaults over the course of multiple configuration calls.  The use of this option is generally considered preferred relative to the others.  That is because as a default it still allows for the server to specify overrides, and as an append it will respect any other previous configuration calls which you may have made at other times and places.
/// $override$ |  Elements within this object will override any options of the same name specified by the server.  Use this option when you do not want to allow the server to specify overrides.  The use of this option will replace any previous use of <code>$override$</code> or <code>$override.append$</code>.
/// $override.append$ |  Elements within this object will append to any previously established <code>$override$</code>.  You may use this without using <code>$override$</code> first, allowing you to specify multiple overrides over the course of multiple configuration calls.  The use of this option is generally preferred to <code>$override$</code>.  That is because as an append it will respect any other previous configuration calls which you may have made at other times and places.
/// The following example will deny the collection of two datapoints, the idfa and idfv.  Ordinarily the best way to do this is through the Kochava dashboard, where these can be controlled within multiple version(s) of an app already in production.  However, if at build time you wanted to explicitly override server-side control, such that these two items effectively always appear in the deny datapoints list, the following code would do so:
/// <h2>Example</h2>
/// \code
/// // consentClientConfigureObject
/// let consentClientConfigureObject =
/// [
///     "$override.append$":
///     [
///         "privacy":
///         [
///             "deny_datapoints":
///             [
///                 "idfa",
///                 "idfv"
///             ]
///         ]
///     ]
/// ]
///
/// // KVAConsentClient
/// KVAConsentClient.shared.configure(with: consentClientConfigureObject, context: .host)
/// KVAConsentClient.shared.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
/// KVAConsentClient.shared.start()
///
/// \endcode\param object An object from which to configure the instance.  This is most commonly a JSON object.
///
/// \param context The context from which the object was provided.  In rare cases this may have some bearing on the proper interpretation of what was provided.
///
- (void)configureWith:(id _Nullable)object context:(KVAContext * _Nullable)context;
/// Configure the instance with an object.
/// This function is equivalent to func configure(with:context) however this does not first dispatch to the globalSerial queue.  It is the protocol conformance of KVAConfigureWithProtocol.  You should not use this function directly unless you have a specific need to not perform the preferred dispatch.
- (void)kva_configureWith:(id _Nullable)object context:(KVAContext * _Nullable)context;
/// Register an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
///
/// \endcode
- (void)registerIdentityWithNameString:(NSString * _Nonnull)nameString valueString:(NSString * _Nonnull)valueString;
/// Unregister an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.unregisterIdentity(withNameString: "_SOME_NAME_")
///
/// \endcode
- (void)unregisterIdentityWithNameString:(NSString * _Nonnull)nameString;
/// Start the consent client instance.
/// An identity must be registered prior to making this call.  To do this, instead see func <code>registerIdentity(withNameString:valueString:)</code>.  This method is called by those two methods, and provides public conformance to protocol KVAStartable.  This method can be used to start an instance of a consent client which was created from decoded JSON.
- (void)start;
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Invalidate the instance.
/// When using this method with the shared instance, you are guaranteed to be re-defaulted a new instance the next time it is referenced, and you may immediately move forward to re-configure and start it.
- (void)invalidate;
/// Invalidate the instance.
/// See func <code>invalidate()</code>
- (void)invalidateWithAsyncBool:(BOOL)asyncBool printLogMessageBool:(BOOL)printLogMessageBool;
/// A feature which is responsible for adding audit entries.
@property (nonatomic, readonly, strong) KVAConsentAudit * _Nonnull audit;
/// A feature which is responsible for controlling and updating the configuration of the consent client instance.
@property (nonatomic, readonly, strong) KVAConsentConfig * _Nonnull config;
/// A feature which is a public configuration for consent.
/// This form of the configuration is a copy.  You should retain and instance within the scope where you are working with it so that the configuration will be consistent and not mutate within that scope.
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration;
/// A feature which is a public configuration for consent— mutable.
/// This form of the configuration can mutate.  The form that the host can access will be a copy so that it does not mutate within their scope (unless they reference the instance multiple times).
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration_mutable;
/// A feature which encapsulates all of the general aspects of a consent client not belonging to any other encapsulated features.
@property (nonatomic, readonly, strong) KVAConsentGeneral * _Nonnull general;
/// A feature which provides networking support.
/// The networking instance manages the exchange of data between the client and various server(s), along with the associated tasks, network transactions, adapters, and instructions.  See class KVANetworking in module KochavaCore.
@property (nonatomic, readonly, strong) KVANetworking * _Nonnull networking;
/// A feature which is responsible for working with US Privacy (IAB).
@property (nonatomic, readonly, strong) KVAUSPrivacy * _Nonnull usPrivacy;
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
/// A string used as a  storage identifier for the shared instance.
/// This is used to further qualify where in persistent storage the information for this instance is stored.  This property should not be used except in very specific circumstances.  Please contact your client success representative if you are interested in using this.  You would set this value to a short unique string consisting of regular alphanumeric characters.
/// Following deployment with a given storage identifer this should never be changed except to represent an entirely new integration.
/// If used, it is imperative that this value be consistently set prior to accessing the shared instance for the first time.  You must make accommodations to set this as early as possible, where it would be prior to any access to var <code>shared</code> throughout all of your code.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable sharedStorageIdString;)
+ (NSString * _Nullable)sharedStorageIdString SWIFT_WARN_UNUSED_RESULT;
+ (void)setSharedStorageIdString:(NSString * _Nullable)sharedStorageIdString;
/// A closure which is called when there is an update to the configuration.
/// This can be used to prompt the user for consent and to enable and/or disable functionality.
@property (nonatomic, copy) void (^ _Nullable didReceiveConfigurationBlock)(KVAConsentConfiguration * _Nonnull);
/// A boolean indicating whether or not the instance has been started.
@property (nonatomic, readonly) BOOL startedBool;
@end


/// A feature which is responsible for controlling and updating the configuration of the consent instance.
/// This feature interfaces with Kochava’s servers to provide a server-based configuration.
SWIFT_CLASS_NAMED("KVAConsentConfig")
@interface KVAConsentConfig : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("KVAConsentConfiguration")
@interface KVAConsentConfiguration : NSObject <NSCopying>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Returns a boolean indicating if a mode is currently present.
- (BOOL)modePresentWithNameString:(NSString * _Nonnull)nameString SWIFT_WARN_UNUSED_RESULT;
/// A dictionary containing arbitrary configuration values meant for the host app’s consumption.
@property (nonatomic, readonly, copy) NSDictionary * _Nonnull hostDictionary;
/// Array of strings indicating the current applicable consent modes.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull modeStringArray;
/// A boolean indicating whether or not at least one configuration has completed and the configuration object is ready for use.
/// This might be checked instead of waiting for the optional closure to be called.
@property (nonatomic, readonly) BOOL readyBool;
@end



/// A feature which is responsible for the collection of datapoints.
/// <h1>Thread Safety</h1>
/// The underlying APIs being used to collect datapoints fall under various classifications of thread safety.  If an API is not thread safe then it must be collected on the main thread, otherwise it may be collected on the caller’s thread.  Anything which must be collected on the main thread must be viewed as asynchronous, along with those APIs which are themselves inherently asynchronous;  however, all other APIs may be viewed as synchronous.  In every case these thread safety classifications apply to the internal implementation stategies of the associated adapters, but the adapters themselves exist in part to create wrappers which have their own API(s) which are themselves uniform and universally thread safe.
/// Apple’s documentation on thread safety can be found here:
/// https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html
/// <h2>Internal Implementation Strategy Classifications</h2>
/// | Class | Safe | Notes |
/// — | — | —
/// Bundle | Yes | Apple’s documentation classifies Bundle under “Thread-Safe Classes and Functions”.
/// Locale | Yes* | Locale thread safety is undocumented by Apple at the time of this writing, but their broader documentation on thread safety says, “Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads.”  Because none of the properties which are being accessed are taken to be mutable, generally speaking, what we are doing is taken to be thread safe.
/// ProcessInfo | Yes | ProcessInfo is said to be thread-safe as of macOS 10.7 and later.
/// UIDevice | Yes* | UIDevice thread safety is undocumented by Apple at the time of this writing, but their broader documentation on thread safety says, “Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads.”  Because none of the properties which are being accessed are taken to be mutable, generally speaking, what we are doing may be thread safe.  However, Apple’s docs also say, “For the most part, UIKit classes should be used only from an application’s main thread. This is particularly true for classes derived from UIResponder or that involve manipulating your application’s user interface in any way.”  UIDevice is part of UIKit, however it is not derived from UIResponder (but rather NSObject).  This method is taken to not be involved in manipulating the application’s user interface.   https://developer.apple.com/documentation/uikit
/// Special | Varies | This classification is used for special cases.  There should be additional documentation in reference(s) which talk about the case.
/// <em>Yes*</em> - Items with this designation are taken to be safe.  They lack some level of documentation and/or clarity where thread safety is concerned, but often generally have a track record of being safe.
SWIFT_CLASS_NAMED("KVAConsentDatapoints")
@interface KVAConsentDatapoints : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A feature which encapsulates all of the general aspects of a consent not belonging to any other encapsulated features.
SWIFT_CLASS_NAMED("KVAConsentGeneral")
@interface KVAConsentGeneral : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Register an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.general.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
///
/// \endcode
- (void)registerIdentityWithNameString:(NSString * _Nonnull)nameString valueString:(NSString * _Nonnull)valueString;
/// Unregister an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.general.unregisterIdentity(withNameString: "_SOME_NAME_")
///
/// \endcode
- (void)unregisterIdentityWithNameString:(NSString * _Nonnull)nameString;
@end


/// A feature which is responsible for consent-specific logging activities.
/// You can set the KVALog.shared.level to control what level of log messages are printed, as well as configure various other options through module KochavaCore class KVALog.
SWIFT_CLASS_NAMED("KVAConsentLogging")
@interface KVAConsentLogging : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class KVAProduct;

/// A class which defines the consent product.
/// A product in this context generally refers to the result of a build.
/// note:
/// This is currently overridden to be a subclass of NSObject rather than KVAProduct so that it can be represented in Objective-C.  If you use KVAProduct it will still build, but the automatic module registration will fail to locate the class.  You can see early evidence of the problem if you also make the shared property be of the class type, where the compiler will say that it cannot use @objc because it cannot be expressed in Objective-C.  This is apparently a problem that Swift has providing Objective-C compatibility to Swift classes which subclass other Swift classes across modules.  For example, KVACoreProduct does not have this problem, presumably because it’s in the same module as KVAProduct.  In order to convert this class to subclass KVAProduct, or to subsequently allow shared to be of the class’ type, a means of registering/loading the class as a Swift-only class would be required.  More importantly, however, we’d need to give up public Objective-C support.  Since that doesn’t seem possible, the only alternative would be that Apple fixes this issue and provides the necessary support, assuming that’s possible.
SWIFT_CLASS_NAMED("KVAConsentProduct")
@interface KVAConsentProduct : NSObject
/// The singleton shared instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAProduct * _Nonnull shared;)
+ (KVAProduct * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Defines the parameters for the tracker product.
SWIFT_CLASS("_TtC14KochavaConsent23KVAConsentProductParams")
@interface KVAConsentProductParams : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A feature which provides for the internal observation of sessions.
SWIFT_CLASS_NAMED("KVAConsentSessions")
@interface KVAConsentSessions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class KVAUSPrivacyStringValue;

SWIFT_CLASS_NAMED("KVAUSPrivacy")
@interface KVAUSPrivacy : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if the publisher intends for this transaction to be covered under the IAB Limited Service Provider Agreement (LSPA).
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull coveredByLSPA;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if explicit notice has been given.
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull explicitNoticeGiven;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if the user has opted out of the sale of their data.
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull userOptedOutOfSale;
/// The IAB US Privacy string.
@property (nonatomic, copy) NSString * _Nullable string;
@end



/// An object which represents the value within the US Privacy String.
SWIFT_CLASS_NAMED("KVAUSPrivacyStringValue")
@interface KVAUSPrivacyStringValue : NSObject
/// An enumerated shared instance of KVAUSPrivacyStringValue for Yes.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull yes;)
+ (KVAUSPrivacyStringValue * _Nonnull)yes SWIFT_WARN_UNUSED_RESULT;
/// An enumerated shared instance of KVAUSPrivacyStringValue for No.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull no;)
+ (KVAUSPrivacyStringValue * _Nonnull)no SWIFT_WARN_UNUSED_RESULT;
/// An enumerated shared instance of KVAUSPrivacyStringValue for Not Applicable.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull notApplicable;)
+ (KVAUSPrivacyStringValue * _Nonnull)notApplicable SWIFT_WARN_UNUSED_RESULT;
/// The name of the value.
@property (nonatomic, readonly, copy) NSString * _Nonnull nameString;
/// The raw string value as found in the IAB US Privacy String at a given position.
@property (nonatomic, readonly, copy) NSString * _Nonnull rawString;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__i386__) && __i386__
// Generated by Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
#ifndef KOCHAVACONSENT_SWIFT_H
#define KOCHAVACONSENT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="KochavaConsent",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


SWIFT_CLASS("_TtC14KochavaConsent7KVACCPA")
@interface KVACCPA : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@protocol KVAConsentAuditEntryAdder;

SWIFT_PROTOCOL("_TtP14KochavaConsent33KVAConsentAuditEntryAdderProvider_")
@protocol KVAConsentAuditEntryAdderProvider
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
@end

@class KVAConsentAuditEntry;

SWIFT_PROTOCOL("_TtP14KochavaConsent25KVAConsentAuditEntryAdder_")
@protocol KVAConsentAuditEntryAdder
/// Adds an audit entry.
- (void)addEntry:(KVAConsentAuditEntry * _Nonnull)entry;
@end

@class NSString;

/// A controller for working with consent audit entries.
SWIFT_CLASS_NAMED("KVAConsentAudit")
@interface KVAConsentAudit : NSObject <KVAConsentAuditEntryAdder, KVAConsentAuditEntryAdderProvider>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)addEntry:(KVAConsentAuditEntry * _Nonnull)entry;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
@end


/// An audit entry.
SWIFT_CLASS_NAMED("KVAConsentAuditEntry")
@interface KVAConsentAuditEntry : NSObject
/// A method which adds an audit entry.
/// \param textString A string of text.
///
+ (void)addWithTextString:(NSString * _Nonnull)textString;
/// A method which adds an audit entry.
/// \param textString A string of text.
///
/// \param adder An instance which conforms to protocol KVAConsentAuditEntryAdderProvider.
///
+ (void)addWithTextString:(NSString * _Nonnull)textString adder:(id <KVAConsentAuditEntryAdderProvider> _Nullable)adder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class KVAUSPrivacy;

SWIFT_PROTOCOL_NAMED("KVAUSPrivacyProvider")
@protocol KVAUSPrivacyProvider
/// An instance of class KVAUSPrivacy.
@property (nonatomic, readonly, strong) KVAUSPrivacy * _Nonnull usPrivacy;
@end

@class KVAConsentConfiguration;

SWIFT_PROTOCOL_NAMED("KVAConsentConfigurationMutableProvider")
@protocol KVAConsentConfigurationMutableProvider
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration_mutable;
@end

@class KVAContext;
@class KVAConsentConfig;
@class KVAConsentGeneral;
@class KVANetworking;

/// The class KVAConsentClient provides an interface between a host application and Kochava’s Consent servers.
SWIFT_CLASS_NAMED("KVAConsentClient")
@interface KVAConsentClient : NSObject <KVAConsentAuditEntryAdderProvider, KVAConsentConfigurationMutableProvider, KVAUSPrivacyProvider>
/// A shared instance, for convenience.
/// This is the preferred way of using an consentClient instance.  To complete the integration you must call func <code>registerIdentity(withNameString:valueString:)</code> followed by func <code>start()</code>.  You may alternatively use a constructor to create your own consentClient.  The shared instance simplifies your implementation as you do not need to store an consentClient instance somewhere in a public location in your own code.
/// By default this instance will use the default storage location equivalent to calling <code>init(storageIdString:)</code> with storageIdString nil.  If you wish to specify an alternative storage location, see var <code>sharedStorageIdString</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAConsentClient * _Nonnull shared;)
+ (KVAConsentClient * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// A shared instance, for convenience— optional.
/// See var <code>shared</code>.  This variable will be nil prior to the shared instance being defaulted.  This may be used to optionally invalidate any existing shared instance without causing it to first be defaulted in the process.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAConsentClient * _Nullable shared_optional;)
+ (KVAConsentClient * _Nullable)shared_optional SWIFT_WARN_UNUSED_RESULT;
/// The shared instance, an ambiguated form of the var <code>shared</code> which conforms to protocol KVASharedPropertyProvider.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) id _Nonnull sharedInstance;)
+ (id _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// Create a consent client.
/// You rarely create instances of class KVAConsentClient.  Instead, you start the provided shared instance using one of the start instance methods.  See static var <code>shared</code>.
/// <h2>Example</h2>
/// \code
/// class MyClass
/// {
///     let consentClient = KVAConsentClient()
/// }
///
/// \endcode
- (nonnull instancetype)init;
/// Create a consentClient.
/// You rarely create instances of class KVAConsentClient.  Instead, you start the provided shared instance using one of the start instance methods.  See static var <code>shared</code>.
/// <h2>Example</h2>
/// \code
/// class MyClass
/// {
///     let consentClient = KVAConsentClient(storageIdString: "alternate")
/// }
///
/// \endcode\param storageIdString An optional storage identifier.  The storage identifier should be left unset (nil) unless you have a reason to not use the default storage space.  See default constructor KVAConsentClient().
///
- (nonnull instancetype)initWithStorageIdString:(NSString * _Nullable)storageIdString OBJC_DESIGNATED_INITIALIZER;
/// Configure the instance with an object.
/// This is the same method which is used to configure the instance when the <code>config</code> response is returned from Kochava’s servers.  It can also be called from the host to change the defaults of various parameters (or else override them).  The structure of the object you provide has the same capability as that which the server may return.  Additionally you can wrap the parameters you provide in special objects with special keys <code>$default$</code>, <code>$default.append$</code>, <code>$override$</code>, or <code>$override.append$</code>, to indicate how these options are treated relative to the server’s options.
/// | Special Key | Treatment  |
/// — | —
/// $default$ |  Elements within this object will serve as a default for any options of the same name when not specified by the server.  The use of this option will replace any previous use of <code>$default$</code> or <code>$default.append$</code>.
/// $default.append$ |  Elements within this object will append to any previously established <code>$default$</code>.  You may use this without using <code>$default$</code> first, allowing you to specify multiple defaults over the course of multiple configuration calls.  The use of this option is generally considered preferred relative to the others.  That is because as a default it still allows for the server to specify overrides, and as an append it will respect any other previous configuration calls which you may have made at other times and places.
/// $override$ |  Elements within this object will override any options of the same name specified by the server.  Use this option when you do not want to allow the server to specify overrides.  The use of this option will replace any previous use of <code>$override$</code> or <code>$override.append$</code>.
/// $override.append$ |  Elements within this object will append to any previously established <code>$override$</code>.  You may use this without using <code>$override$</code> first, allowing you to specify multiple overrides over the course of multiple configuration calls.  The use of this option is generally preferred to <code>$override$</code>.  That is because as an append it will respect any other previous configuration calls which you may have made at other times and places.
/// The following example will deny the collection of two datapoints, the idfa and idfv.  Ordinarily the best way to do this is through the Kochava dashboard, where these can be controlled within multiple version(s) of an app already in production.  However, if at build time you wanted to explicitly override server-side control, such that these two items effectively always appear in the deny datapoints list, the following code would do so:
/// <h2>Example</h2>
/// \code
/// // consentClientConfigureObject
/// let consentClientConfigureObject =
/// [
///     "$override.append$":
///     [
///         "privacy":
///         [
///             "deny_datapoints":
///             [
///                 "idfa",
///                 "idfv"
///             ]
///         ]
///     ]
/// ]
///
/// // KVAConsentClient
/// KVAConsentClient.shared.configure(with: consentClientConfigureObject, context: .host)
/// KVAConsentClient.shared.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
/// KVAConsentClient.shared.start()
///
/// \endcode\param object An object from which to configure the instance.  This is most commonly a JSON object.
///
/// \param context The context from which the object was provided.  In rare cases this may have some bearing on the proper interpretation of what was provided.
///
- (void)configureWith:(id _Nullable)object context:(KVAContext * _Nullable)context;
/// Configure the instance with an object.
/// This function is equivalent to func configure(with:context) however this does not first dispatch to the globalSerial queue.  It is the protocol conformance of KVAConfigureWithProtocol.  You should not use this function directly unless you have a specific need to not perform the preferred dispatch.
- (void)kva_configureWith:(id _Nullable)object context:(KVAContext * _Nullable)context;
/// Register an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
///
/// \endcode
- (void)registerIdentityWithNameString:(NSString * _Nonnull)nameString valueString:(NSString * _Nonnull)valueString;
/// Unregister an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.unregisterIdentity(withNameString: "_SOME_NAME_")
///
/// \endcode
- (void)unregisterIdentityWithNameString:(NSString * _Nonnull)nameString;
/// Start the consent client instance.
/// An identity must be registered prior to making this call.  To do this, instead see func <code>registerIdentity(withNameString:valueString:)</code>.  This method is called by those two methods, and provides public conformance to protocol KVAStartable.  This method can be used to start an instance of a consent client which was created from decoded JSON.
- (void)start;
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Invalidate the instance.
/// When using this method with the shared instance, you are guaranteed to be re-defaulted a new instance the next time it is referenced, and you may immediately move forward to re-configure and start it.
- (void)invalidate;
/// Invalidate the instance.
/// See func <code>invalidate()</code>
- (void)invalidateWithAsyncBool:(BOOL)asyncBool printLogMessageBool:(BOOL)printLogMessageBool;
/// A feature which is responsible for adding audit entries.
@property (nonatomic, readonly, strong) KVAConsentAudit * _Nonnull audit;
/// A feature which is responsible for controlling and updating the configuration of the consent client instance.
@property (nonatomic, readonly, strong) KVAConsentConfig * _Nonnull config;
/// A feature which is a public configuration for consent.
/// This form of the configuration is a copy.  You should retain and instance within the scope where you are working with it so that the configuration will be consistent and not mutate within that scope.
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration;
/// A feature which is a public configuration for consent— mutable.
/// This form of the configuration can mutate.  The form that the host can access will be a copy so that it does not mutate within their scope (unless they reference the instance multiple times).
@property (nonatomic, readonly, strong) KVAConsentConfiguration * _Nonnull configuration_mutable;
/// A feature which encapsulates all of the general aspects of a consent client not belonging to any other encapsulated features.
@property (nonatomic, readonly, strong) KVAConsentGeneral * _Nonnull general;
/// A feature which provides networking support.
/// The networking instance manages the exchange of data between the client and various server(s), along with the associated tasks, network transactions, adapters, and instructions.  See class KVANetworking in module KochavaCore.
@property (nonatomic, readonly, strong) KVANetworking * _Nonnull networking;
/// A feature which is responsible for working with US Privacy (IAB).
@property (nonatomic, readonly, strong) KVAUSPrivacy * _Nonnull usPrivacy;
@property (nonatomic, readonly, strong) id <KVAConsentAuditEntryAdder> _Nonnull auditEntryAdder;
/// A string used as a  storage identifier for the shared instance.
/// This is used to further qualify where in persistent storage the information for this instance is stored.  This property should not be used except in very specific circumstances.  Please contact your client success representative if you are interested in using this.  You would set this value to a short unique string consisting of regular alphanumeric characters.
/// Following deployment with a given storage identifer this should never be changed except to represent an entirely new integration.
/// If used, it is imperative that this value be consistently set prior to accessing the shared instance for the first time.  You must make accommodations to set this as early as possible, where it would be prior to any access to var <code>shared</code> throughout all of your code.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nullable sharedStorageIdString;)
+ (NSString * _Nullable)sharedStorageIdString SWIFT_WARN_UNUSED_RESULT;
+ (void)setSharedStorageIdString:(NSString * _Nullable)sharedStorageIdString;
/// A closure which is called when there is an update to the configuration.
/// This can be used to prompt the user for consent and to enable and/or disable functionality.
@property (nonatomic, copy) void (^ _Nullable didReceiveConfigurationBlock)(KVAConsentConfiguration * _Nonnull);
/// A boolean indicating whether or not the instance has been started.
@property (nonatomic, readonly) BOOL startedBool;
@end


/// A feature which is responsible for controlling and updating the configuration of the consent instance.
/// This feature interfaces with Kochava’s servers to provide a server-based configuration.
SWIFT_CLASS_NAMED("KVAConsentConfig")
@interface KVAConsentConfig : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("KVAConsentConfiguration")
@interface KVAConsentConfiguration : NSObject <NSCopying>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Returns a boolean indicating if a mode is currently present.
- (BOOL)modePresentWithNameString:(NSString * _Nonnull)nameString SWIFT_WARN_UNUSED_RESULT;
/// A dictionary containing arbitrary configuration values meant for the host app’s consumption.
@property (nonatomic, readonly, copy) NSDictionary * _Nonnull hostDictionary;
/// Array of strings indicating the current applicable consent modes.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull modeStringArray;
/// A boolean indicating whether or not at least one configuration has completed and the configuration object is ready for use.
/// This might be checked instead of waiting for the optional closure to be called.
@property (nonatomic, readonly) BOOL readyBool;
@end



/// A feature which is responsible for the collection of datapoints.
/// <h1>Thread Safety</h1>
/// The underlying APIs being used to collect datapoints fall under various classifications of thread safety.  If an API is not thread safe then it must be collected on the main thread, otherwise it may be collected on the caller’s thread.  Anything which must be collected on the main thread must be viewed as asynchronous, along with those APIs which are themselves inherently asynchronous;  however, all other APIs may be viewed as synchronous.  In every case these thread safety classifications apply to the internal implementation stategies of the associated adapters, but the adapters themselves exist in part to create wrappers which have their own API(s) which are themselves uniform and universally thread safe.
/// Apple’s documentation on thread safety can be found here:
/// https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html
/// <h2>Internal Implementation Strategy Classifications</h2>
/// | Class | Safe | Notes |
/// — | — | —
/// Bundle | Yes | Apple’s documentation classifies Bundle under “Thread-Safe Classes and Functions”.
/// Locale | Yes* | Locale thread safety is undocumented by Apple at the time of this writing, but their broader documentation on thread safety says, “Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads.”  Because none of the properties which are being accessed are taken to be mutable, generally speaking, what we are doing is taken to be thread safe.
/// ProcessInfo | Yes | ProcessInfo is said to be thread-safe as of macOS 10.7 and later.
/// UIDevice | Yes* | UIDevice thread safety is undocumented by Apple at the time of this writing, but their broader documentation on thread safety says, “Immutable objects are generally thread-safe. Once you create them, you can safely pass these objects to and from threads.”  Because none of the properties which are being accessed are taken to be mutable, generally speaking, what we are doing may be thread safe.  However, Apple’s docs also say, “For the most part, UIKit classes should be used only from an application’s main thread. This is particularly true for classes derived from UIResponder or that involve manipulating your application’s user interface in any way.”  UIDevice is part of UIKit, however it is not derived from UIResponder (but rather NSObject).  This method is taken to not be involved in manipulating the application’s user interface.   https://developer.apple.com/documentation/uikit
/// Special | Varies | This classification is used for special cases.  There should be additional documentation in reference(s) which talk about the case.
/// <em>Yes*</em> - Items with this designation are taken to be safe.  They lack some level of documentation and/or clarity where thread safety is concerned, but often generally have a track record of being safe.
SWIFT_CLASS_NAMED("KVAConsentDatapoints")
@interface KVAConsentDatapoints : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A feature which encapsulates all of the general aspects of a consent not belonging to any other encapsulated features.
SWIFT_CLASS_NAMED("KVAConsentGeneral")
@interface KVAConsentGeneral : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Register an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.general.registerIdentity(
///     withNameString: "_SOME_NAME_",
///     valueString: "_SOME_VALUE_"
/// )
///
/// \endcode
- (void)registerIdentityWithNameString:(NSString * _Nonnull)nameString valueString:(NSString * _Nonnull)valueString;
/// Unregister an identity.
/// <h2>Example</h2>
/// \code
/// KVAConsentClient.shared.general.unregisterIdentity(withNameString: "_SOME_NAME_")
///
/// \endcode
- (void)unregisterIdentityWithNameString:(NSString * _Nonnull)nameString;
@end


/// A feature which is responsible for consent-specific logging activities.
/// You can set the KVALog.shared.level to control what level of log messages are printed, as well as configure various other options through module KochavaCore class KVALog.
SWIFT_CLASS_NAMED("KVAConsentLogging")
@interface KVAConsentLogging : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class KVAProduct;

/// A class which defines the consent product.
/// A product in this context generally refers to the result of a build.
/// note:
/// This is currently overridden to be a subclass of NSObject rather than KVAProduct so that it can be represented in Objective-C.  If you use KVAProduct it will still build, but the automatic module registration will fail to locate the class.  You can see early evidence of the problem if you also make the shared property be of the class type, where the compiler will say that it cannot use @objc because it cannot be expressed in Objective-C.  This is apparently a problem that Swift has providing Objective-C compatibility to Swift classes which subclass other Swift classes across modules.  For example, KVACoreProduct does not have this problem, presumably because it’s in the same module as KVAProduct.  In order to convert this class to subclass KVAProduct, or to subsequently allow shared to be of the class’ type, a means of registering/loading the class as a Swift-only class would be required.  More importantly, however, we’d need to give up public Objective-C support.  Since that doesn’t seem possible, the only alternative would be that Apple fixes this issue and provides the necessary support, assuming that’s possible.
SWIFT_CLASS_NAMED("KVAConsentProduct")
@interface KVAConsentProduct : NSObject
/// The singleton shared instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAProduct * _Nonnull shared;)
+ (KVAProduct * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Defines the parameters for the tracker product.
SWIFT_CLASS("_TtC14KochavaConsent23KVAConsentProductParams")
@interface KVAConsentProductParams : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A feature which provides for the internal observation of sessions.
SWIFT_CLASS_NAMED("KVAConsentSessions")
@interface KVAConsentSessions : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class KVAUSPrivacyStringValue;

SWIFT_CLASS_NAMED("KVAUSPrivacy")
@interface KVAUSPrivacy : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if the publisher intends for this transaction to be covered under the IAB Limited Service Provider Agreement (LSPA).
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull coveredByLSPA;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if explicit notice has been given.
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull explicitNoticeGiven;
/// An enumerated instance of KVAUSPrivacyStringValue indicating if the user has opted out of the sale of their data.
@property (nonatomic, strong) KVAUSPrivacyStringValue * _Nonnull userOptedOutOfSale;
/// The IAB US Privacy string.
@property (nonatomic, copy) NSString * _Nullable string;
@end



/// An object which represents the value within the US Privacy String.
SWIFT_CLASS_NAMED("KVAUSPrivacyStringValue")
@interface KVAUSPrivacyStringValue : NSObject
/// An enumerated shared instance of KVAUSPrivacyStringValue for Yes.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull yes;)
+ (KVAUSPrivacyStringValue * _Nonnull)yes SWIFT_WARN_UNUSED_RESULT;
/// An enumerated shared instance of KVAUSPrivacyStringValue for No.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull no;)
+ (KVAUSPrivacyStringValue * _Nonnull)no SWIFT_WARN_UNUSED_RESULT;
/// An enumerated shared instance of KVAUSPrivacyStringValue for Not Applicable.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAUSPrivacyStringValue * _Nonnull notApplicable;)
+ (KVAUSPrivacyStringValue * _Nonnull)notApplicable SWIFT_WARN_UNUSED_RESULT;
/// The name of the value.
@property (nonatomic, readonly, copy) NSString * _Nonnull nameString;
/// The raw string value as found in the IAB US Privacy String at a given position.
@property (nonatomic, readonly, copy) NSString * _Nonnull rawString;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif
